\section{Kvantno računalništvo ter algebrajski učinki in diagrami}

\subsection{Kvantna vezja}

Kvantne programe lahko predstavimo kot diagrame vezja.
Škatle predstavljajo unitarna vrata, črte med njimi pa žice;
po enojnih žicah tečejo kubiti, po dvojnih pa klasični biti (\(0\) ali \(1\)).
Pike na žici (in potem navpična žica ven) pomenijo kontrolo;
prazna pika kontrolira \airquotes{na nič}, polna pa \airquotes{na ena}.
Škatla s števcem predstavlja meritev.
Taka vezja beremo od leve proti desni.
Podrobnejši opis lahko najdete v \cite{ess-qc}. %TODO: opiši?

Spodaj sta dva primera kvantnih programov, opisana z besedami in diagrami, ki ju bomo srečali tudi še kasneje.

\begin{example}[Projekcija na \(z\)-os]\label{ex:proj-z}
    Najprej izmerimo \(a\) in nato glede na rezultat svež kubit bodisi negiramo bodisi ne.
    Na Blochovi sferi to zgleda približno kot projekcija na \(z\)-os (edina kubita na \(z\)-osi sta \( \ket{\mb0} \) in \( \ket{\mb1} = X \ket{\mb0} \)).
    \[ \Qcircuit @C=1em @R=.7em {
            & \lstick{\ket{\mb0}} & \gate{\g X} & \rstick{b} \qw\\
            \lstick{a} & \meter & \cctrl{-1}
        }
    \]
\end{example}

\begin{example}[Naključna rotacija faze]\label{ex:rand-ph-shift}
    Meritev Hadamardovega vektorja simulira pravičen met kovanca,
    vrata \(Z\) pa rotirajo fazo, torej bomo v polovici primerov kubitu \(a\) rotirali fazo.
    \[ \Qcircuit @C=1em @R=.7em {
            \lstick{a} & \qw & \qw & \qw & \qw & \gate{\g Z} & \rstick{a}\qw\\
            && \lstick{\ket{\mb0}} & \gate{\had} & \meter & \cctrl{-1}
        }
    \]
\end{example}

Spomnimo se zdaj trditve o ekvivalenci definicij meritev:

\begin{proposition}
    V kvantnem računalništvu je meritev definirana s kolapsom ekvivalentna meritvi definirani z uničenjem kubita.
\end{proposition}

\begin{proof}
    Očitno je prva definicija močnejša od druge, tako da moramo dokazati zgolj, da lahko iz druge definicije simuliramo obnašanje prve.
    Ampak če pogledamo prvi primer zgoraj, projekcijo na \(z\)-os, je to natanko to, kar potrebujemo. Izmerimo kubit \(a\) in dobimo klasični bit \(M{\p a}\), s katerim potem nov kubit nastavimo bodisi na \(\ket{\mb0}\) bodisi na \(\ket{\mb1}\), kar je pa natanko vrednost kubita \(a\) po meritvi v skladu s prvo definicijo.
\end{proof}

\subsection{Algebrajski učinki}

Diagrami so v rabi že dolgo časa, vendar pa so manipulacije teh diagramov nerodne;
na naših programih raje izvajamo bolj matematične pristope, in zato na programe raje gledamo iz bolj matematičnega vidika. Izkaže se, da lahko zelo dobro predstavimo naše programe z algebrajskimi izrazi.
Vse naše operacije na kubitih lahko interpretiramo kot računske učinke nekih funkcij, katere pa lahko predstavimo z algebrajsko teorijo, ki jo nato lahko razvijamo povsem matematično.

Z računskimi učinki se med programiranjem pogosto srečamo: globalno stanje spremenljivk, vhodno/izhodne naprave, naključnost, izjeme, nedeterminizem, ipd.

\begin{definition}[Računski učinki]
    Če ima funkcija ali operacija še kak navzven viden učinek poleg vrnjene vrednosti, slednjemu pravimo računski učinek (učinek računanja).
\end{definition}

\begin{definition}[Algebrajski učinki]
    Računskim učinkom, ki jih lahko predstavimo s kašno algebrajsko teorijo, pravimo algebrajski učinki.
\end{definition}

Večina zanimivih (in vseh zgoraj naštetih) učinkov je algebrajskih, tako da je pristop v tem delu uporaben tudi bolj v splošnem.

% TODO: fill out with some theory on algebraic effects and how they work in our particular example
