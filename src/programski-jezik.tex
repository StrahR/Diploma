\section{Programski jezik}
Definirajmo sedaj nek preprost programski jezik za delo s kvantnim računalnikom.
% Temeljil bo na linearnih tipih in algebrajskih učinkih.
Kasneje bi ta jezik lahko razširili še z ostalimi konstrukti, ki smo jih navajeni, kot so naravna števila, vsote, neskončni tipi (seznami), ipd., ampak je za teoretično obravnavo bolj praktično delati s čim preprostejšim jezikom.

\subsection{Sintaksa}
Poznamo sledeče sintaktične elemente:
%LTeX: enabled=false
\begin{table}[H]
\vspace{-1em}
\begin{align*}
    t ∷=&\ x{\p{a₁,…,aₚ}}                                   && \text{nadaljevanje}\\
    \mid&\ \new{a}{t}                                       && \text{inicializacija kubita}\\
    \mid&\ \apply{U}{\oldvec{a}}{t}                         && \text{uporaba vrat}\\
    \mid&\ \measure{a}{t₀}{t₁}                              && \text{meritev}\\
    \mid&\ \discard{a}{t}                                   && \text{uničenje}
    % \mid&\ \lam{a}{t}                                       && \text{lambda abstrakcija}
\end{align*}
\vspace{-1em}
\caption{Sintaksa jezika}
\end{table}
%LTeX: enabled=true

\subsubsection*{Nadaljevanje}
Naj bo \(x\) poljubno nadaljevanje, \(a₁,…,aₚ\) pa vektor kubitov.
Potem je \(x{\p{a₁,…,aₚ}}\) izraz, ki nadaljuje izvajanje v \(x\) s kubiti \(a₁,…,aₚ\).

\subsubsection*{Inicializacija kubita}
Ukaz \(\new{a}{}\) se obnaša podobno kot \(∀a.\), \(∃a.\), ali \(λa.\);
karkoli je po piki (do zaklepaja ali enačaja) vzame kot del izraza \(t\).
Izraz \(t\) je lahko poljuben izraz s prostim kubitom \(a\), \(\new{a}{t}\) pa interpretiramo, kot da najprej kubit \(a\) nastavimo na \(\ket{\mb0}\) in nato izvedemo \(t\).

\subsubsection*{Uporaba vrat}
V zapisu \(\apply{U}{\oldvec{a}}{t}\) je \(\oldvec{a}\) nek vektor kubitov, ki ga bomo pisali kot \(a₁,…,aₚ\), kjer so \(aᵢ\) posamezni kubiti.

\subsubsection*{Meritev}
Ukaz \(?ₐ\) izmeri kubit \(a\), in nato glede na rezultat nadaljuje z izvajanjem bodisi \(t₀\) bodisi \(t₁\), glede na rezultat meritve. To bo uničilo kubit, torej ga v nadaljevanju ne smemo uporabiti.
Če je kubit del prepletenega stanja, moramo to meritev interpretirati ustrezno z definicijo meritve vektorja na primernem mestu.

\subsubsection*{Uničenje}
Ker je uničenje zgolj okrajšava za meritev, po kateri nadaljujemo na isti način ne glede na rezultat, upošteva vsa gornja pravila.

% \subsubsection*{Lambda abstrakcija}
% Lambda abstrakcijo bomo uporabili za tvorjenje operacij na nadaljevanjih (recimo primera \ref{ex:5} in \ref{ex:6} spodaj).

\subsection{Primeri}
\begin{example*}\label{ex:1}
    Definiramo lahko analog ukazu \(ν\), ki kubit nastavi na \(\ket{\mb1}\) namesto \(\ket{\mb0}\):
    \[ \new{₁a}{t} ≔ \new{a}{\apply{X}{a}{t}}. \]
    Ukaz \(ν\) lahko potem označimo tudi z \(ν₀\). 
\end{example*}

\begin{example*}\label{ex:2}
    S kvantnimi operacijami lahko modeliramo naključnost; definirajmo funkcijo \(\op{rand}\), ki naključno izbere eno od nadaljevanj:
    \[ \op{rand}{\p{t, u}} ≔ \new{a}{\apply{\had}{a}{\measure{a}{t}{u}}}. \]
\end{example*}

\begin{example*}\label{ex:3}
    Bellovo stanje \(\state{\ket{\mb{00}} + \ket{\mb{11}}}\) lahko definiramo tako:
    \[ \op{bell}{\p{x}} ≔ \new{a}{\new{b}{\apply{\had}{a}{\apply{\ctl X}{a,b}{x(a,b)}}}}. \]
\end{example*}

\begin{example*}\label{ex:4}
    Kot v prvem primeru, bi tudi ukaz \(\op{disc}\) lahko definirali izključno znotraj jezika:
    \[ \discard{a}{t} ≔ \measure{a}{t}{t}. \]
    Izkaže se, da je ta operacija bolj pomembna kot primer \ref{ex:1}, tako da jo vseeno vključimo neposredno v sintakso jezika.
\end{example*}

\begin{example*}\label{ex:5}
    Oglejmo si zdaj še primera \ref{ex:proj-z} in \ref{ex:c-rot} iz prejšnjega razdelka, najprej projekcijo na \(z\)-os:
    \[ \op{proj}{\p{a;\,x}} ≔ \measurebr{a}{\new{₀a}{x(a)}}{\new{₁a}{x(a)}}. \]
\end{example*}

\begin{example*}\label{ex:6}
    Drugi primer je bil naključna rotacija faze. Uporabimo primer \ref{ex:2}:
    \[ \op{c-rot}{\p{a;\,x}} ≔ \op{rand}{\p{x(a), \apply{Z}{a}{x(a)}}}. \]
\end{example*}

\subsection{Teorija tipov}
Sistem tipov se v programske jezike pogosto uvede zaradi večje varnosti;
preprečijo namreč pisanje veliko nesmiselnih programov.
Pri nas pa tipi opravljajo še dodatno funkcijo:
skrbijo, da spremenljivke uporabljamo \airquotes{linearno}.
To je prednost uporabe linearne teorije tipov namesto navadne teorije tipov za formalizacijo kvantnega računalništva.

\subsubsection{Linearnost}
Kot linearnost razumemo pogoj, da se vsako hipotezo (rečemo tudi parameter, argument, predpostavko, surovino, …) uporabi natanko enkrat.
Linearna logika nam torej na primer formalizira razne procese, kjer iz ene stvari \airquotes{naredimo} drugo, in s tem prvo stvar \airquotes{porabimo}.
Na linearno logiko lahko tudi gledamo kot semantiko \airquotes{iger} ali \airquotes{interakcij}.
Še bolj pomembno pa je, da na linearno logiko lahko gledamo kot \airquotes{pravo} obliko kvantne logike,
ki nam pa dopušča tudi bistveno večjo splošnost.
Že iz imena lahko sklepamo, da se kvantna logika uporablja namesto klasične logike prav tako, kot se kvantna fizika uporablja namesto klasične fizike.
%TODO: citation in nlab quantum logic

Spomnimo se, da z unitarnimi transformacijami (kvantnimi vrati) kubitov ne moremo niti klonirati, niti uničiti.
To je natanko pogoj linearnosti.
Uporaba vrat je res linearna, saj deluje na vseh vhodnih kubitih, do njihove stare vrednosti pa ne moremo več dostopati.
Prav tako je tudi meritev linearna, saj porabi en kubit, ki ga nato ne moremo več uporabljati.
Ker sta to edina načina s katerimi lahko vplivamo na stanja (obstoječih) kubitov, bodo tudi vse funkcije na kubitih linearne.
Če torej iz linearne logike izpeljemo t.i. linearno teorijo tipov, se pogoj linearnosti naravno pretvori v pogoj, da moramo vsak argument funkciji uporabiti natanko enkrat, kar je natanko to, kar za funkcije na kubitih v fiziki res velja.
Ker pogoj linearnosti ne velja za klasične bite (te lahko kopiramo, kolikor hočemo) bomo rekli, da so naše funkcije linearne le na \airquotes{kvantnih tipih}.

%TODO: cite nlab+girard "Za natančno definicijo linearne logike si oglejte…"

\subsubsection{Sistem tipov}
Naš sistem tipov zgradimo iz dela linearne logike imenovanega multiplikativna intuitionistična linearna logika.
Ta vsebuje zgolj tri simbole \(⊗, \mb1, ⊸\), katerim bomo pa dodali še eno konstanto (kubite).
%TODO: explain intuitionistic logic?
%TODO: inferrence rules for MILL?

Pripadajoče tipe lahko potem zgradimo s sledečimi konstruktorji:
\begin{table}[H]
\vspace{-1em}
\begin{align*}
    A,B ∷=&\ \unit                                      && \text{tip z enim elementom } ()\\
      \mid&\ \qbit                                      && \text{tip kubitov}\\
      \mid&\ A⊗B                                        && \text{tenzorski produkt}\\
      \mid&\ A ⊸ B                                      && \text{funkcijski tip}
\end{align*}
\vspace{-1em}
\caption{Sistem tipov}
\end{table}
\begin{remark}
    Edini možni tipi v našem jeziku so \(\qbit^{⊗n}\) ali \(\qbit^{⊗m} ⊸ \qbit^{⊗n}\), kjer sta \(m,n ∈ ℕ\) poljubna.
    To sledi iz enakosti \(A ⊸ (B ⊸ C) = A⊗B ⊸ C\).
    Tipi oblike \((A ⊸ B) ⊸ C\) so sicer veljavni, vendar elementov teh tipov v našem jeziku ne moremo tvoriti.
\end{remark}
\begin{remark}
    Ker je \(\unit\) enota za tenzorski produkt, velja \(\qbit^{⊗0} = \unit\).
\end{remark}

\begin{definition}
    Naj zapis oblike \(\sseq{Γ}{x : A}\) pomeni, da ima \emph{\(x\) tip \(A\) v kontekstu \(Γ\)}.
    Kontekst \(Γ\) je seznam dodelitev tipov spremenljivkam.
    V našem primeru, bomo za \(Γ\) pisali \(x₁:m₁,…,xₖ:mₖ \mid a₁,…,aₚ\),
    kjer so \(xᵢ\) nadaljevanja (oziroma računske spremenljivke) tipa \(\qbit^{⊗mᵢ} ⊸ Aᵢ\), \(aᵢ\) pa kubiti (torej tipa \(\qbit\)).
\end{definition}

Pravila za določitev tipov programom našega jezika so torej takšna:
%LTeX: enabled=false
\begin{table}[H]
\begin{mathpar}
    \inferrule
        {(x:m)∈Γ \\ x : \qbit^{⊗m} ⊸ A}
        {\sequent{Γ}{a₁,…,aₘ}{x(a₁, …, aₘ) : A}}
    \and
    \inferrule
        {\sequent{Γ}{Δ,a}{        t  : A}}
        {\sequent{Γ}{Δ  }{\new{a}{t} : A}}
    \and
    \inferrule
        {\sequent{Γ}{Δ,\oldvec{a}}{                      t  : A} \\ U ∈ \U[p]}
        {\sequent{Γ}{Δ,\oldvec{a}}{\apply{U}{\oldvec{a}}{t} : A}}
    \and
    \inferrule
        {\sequent{Γ}{Δ}{t₀ : A}\\
         \sequent{Γ}{Δ}{t₁ : A}}
        {\sequent{Γ}{Δ, a}{\measure{a}{t₀}{t₁} : A}}
    \and
    \inferrule
        {\sequent{Γ}{Δ  }{            t  : A}}
        {\sequent{Γ}{Δ,a}{\discard{a}{t} : A}}
    % \and
    % \inferrule
    %     {\sequent{Γ}{Δ,a}{t : A}}
    %     {\sequent{Γ}{Δ}{\lam{a}{t} : \qbit ⊸ A}}
    % \and
    % \inferrule
    %     {\sequent{Γ}{-}{x : \qbit^{⊗m} ⊸ A}}
    %     {\sequent{Γ,x:m}{a₁,…,aₚ}{t : B}}
    % \and
    % \inferrule
    %     {(x:n)∈Γ}
    %     {\sequent{Γ}{Δ}{x : \qbit^{⊗n} ⊸ A}}
    %TODO: one more rule?
    %TODO: simultaneous substitution rule?
\end{mathpar}
\caption{Pravila za dodeljevanje tipov}
\end{table}
%LTeX: enabled=true

Pravil za tvorjenje elementov tipa \(A ⊸ B\) sicer nimamo, ampak vseeno z njimi označimo nadaljevanja.
%TODO: is this right?

\subsection{Aksiomi}
Izkaže se, da je nabor aksiomov, ki jih potrebujemo za polno karakterizacijo kvantnih programov relativno majhen: potrebujemo jih zgolj \(12\) in kot bomo videli nismo žrtvovali preprostosti, da smo prišli do te številke.

Aksiome za enakost programov~\cite{algeff-lin-qpl} lahko delimo na dva dela: prvih pet je glavnih, ostalih sedem pa bolj \airquotes{administrativnih} oziroma pomožnih.
Slednji nam povejo zgolj, da se uporaba vrat strinja s strukturo unitarnih matrik,
ter da operacije komutirajo, kolikor vezava spremenljivk (in vrstni red uporabe matrik) dopušča.

\begin{axiom}{Kvantna negacija pred meritvijo je negacija po meritvi:}\label{ax:A}
    \( \apply{X}{a}{\measure{a}{x}{y}} = \measure{a}{y}{x} \).
\end{axiom}

\begin{axiom}{Kvantna kontrola je po meritvi kot klasična kontrola:}\label{ax:B}
    \( \applyd{U, V}{a,b}{\measure{a}{x(b)}{y(b)}}
       = \measurebr{a}{\apply{U}{b}{x(b)}}{\apply{V}{b}{y(b)}} \).
\end{axiom}

\begin{axiom}{Kvantna vrata uporabljena na zavrženih kubitih so odveč:}\label{ax:C}
    \( \apply{U}{a}{\discard{a}{t}} = \discard{a}{t} \).
\end{axiom}

\begin{axiom}{Novi kubiti so \( \ket{\mb0} \) glede na meritev:}\label{ax:D}
    \( \new{a}{\measure{a}{x}{y}} = x \).
\end{axiom}

\begin{axiom}{Novi kubiti so \( \ket{\mb0} \) glede na kontrolo:}\label{ax:E}
    \( \new{a}{\applyd{U,V}{a,b}{x{\p{a,b}}}} = \apply{U}{b}{\new{a}{x{\p{a,b}}}} \).
\end{axiom}

\begin{axiom}{Spoštovanje simetrične grupe \( \U[n] \):}\label{ax:F}
    \( \apply{swap}{a,b}{x{\p{a,b}}} = x{\p{b,a}} \),
\end{axiom}

\begin{axiom}{}\label{ax:G}
    \( \apply{I}{a}{x{\p a}} = x{\p a} \),
\end{axiom}

\begin{axiom}{}\label{ax:H}
    \( \apply{UV}{a}{x{\p a}} = \apply{V}{a}{\apply{U}{a}{x{\p a}}} \),
\end{axiom}

\begin{axiom}{}\label{ax:I}
    \( \apply{U⊗V}{a,b}{x{\p{a,b}}} = \apply{U}{a}{\apply{V}{b}{x{\p{a,b}}}} \).
\end{axiom}

\begin{axiom}{Komutativnost:}\label{ax:J}
    \( \measurebr{a}{\measure{b}{u}{v}}{\measure{b}{x}{y}}
       = \measurebr{b}{\measure{a}{u}{x}}{\measure{a}{v}{y}} \),
\end{axiom}

\begin{axiom}{}\label{ax:K}
    \( \new{a}{\new{b}{x{\p{a,b}}}} = \new{b}{\new{a}{x{\p{a,b}}}} \),
\end{axiom}

\begin{axiom}{}\label{ax:L}
    \( \new{a}{\measure{b}{x{\p a}}{y{\p a}}} = \measurebr{b}{\new{a}{x{\p a}}}{\new{a}{y{\p a}}} \).
\end{axiom}

Uporabimo sedaj zgornje aksiome, da dokažemo, da sta primera \ref{ex:5} in \ref{ex:6} dejansko enaka.
V dokazu bomo poleg aksiomov uporabili še dve enakosti matrik, \(\ctl{X}⋅\swap⋅\ctl{X} \stackrel{(*)}{=} \swap⋅\ctl{X}⋅\swap\) in \(\swap⋅\ctl{X}⋅\swap \stackrel{(†)}{=} (\had⊗I)⋅\ctl{Z}⋅(\had⊗I)\).

\begin{align*}
     &\ \measurebr{b}{\new{a}{x(a)}}{\new{a}{\apply{X}{a}{x(a)}}}               &\\
    =&\ \new{a}{\measure{b}{x(a)}{\apply{X}{a}{x(a)}}}                          &(\ref{ax:L})\\
    =&\ \new{a}{\apply{\ctl X}{b,a}{\measure{b}{x(a)}{x(a)}}}                   &(\ref{ax:B})\\
    =&\ \new{a}{\apply{\ctl X}{b,a}{\discard{b}{x(a)}}}                         &(\text{def.})\\
    =&\ \new{a}{\apply{\ctl X}{a,b}{\apply{\ctl X}{b,a}{\discard{a}{x(b)}}}}    &(*)\\
    =&\ \new{a}{\apply{\ctl X}{b,a}{\discard{a}{x(b)}}}                         &(\ref{ax:E})\\
    =&\ \new{a}{\apply{\had}{a}{\apply{\ctl Z}{a,b}{\apply{\had}{a}{\discard{a}{x(b)}}}}}&(†)\\
    =&\ \new{a}{\apply{\had}{a}{\apply{\ctl Z}{a,b}{\discard{a}{x(b)}}}}        &(\ref{ax:C})\\
    =&\ \new{a}{\apply{\had}{a}{\measure{a}{x(b)}{\apply{Z}{b}{x(b)}}}}         &(\ref{ax:B})
\end{align*}

Kasneje bomo to enakost preverili še z algebrajsko teorijo.
