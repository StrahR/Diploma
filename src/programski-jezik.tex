\section{Aksiomi kvantnega računalništva}
Definirajmo sedaj nek preprost jezik za opis kvantnega računalništva.
Kasneje lahko iz tega jezik razvijemo dejanski programski jezik, opremljen z ostalimi konstrukti, ki smo jih navajeni, kot so naravna števila, vsote, tipi, ipd., ampak je za teoretično obravnavo bolj praktično delati s čim preprostejšim jezikom.

\subsection{Sintaksa}
Poznamo sledeče sintaktične elemente:
%LTeX: enabled=false
\begin{table}[H]
\vspace{-1em}
\begin{align*}
    t ∷=&\ x{\p{a₁,…,aₚ}}                                   && \text{računska spremenljivka}\\
    \mid&\ \new{a}{t}                                       && \text{inicializacija kubita}\\
    \mid&\ \apply{U}{\oldvec{a}}{t}                         && \text{uporaba vrat}\\
    \mid&\ \measure{a}{t₀}{t₁}                              && \text{meritev}
    % \mid&\ \discard{a}{t}                                   && \text{uničenje}
    % \mid&\ \lam{a}{t}                                       && \text{lambda abstrakcija}
\end{align*}
\vspace{-1em}
\caption{Sintaksa jezika}
\end{table}
%LTeX: enabled=true

\subsubsection*{Računska spremenljivka}
Naj bo \(x\) poljuben program na \(p\) kubitih (pišemo \(x : p\)), \(a₁,…,aₚ\) pa vektor kubitov.
Potem je \(x{\p{a₁,…,aₚ}}\) izraz, ki nadaljuje izvajanje v \(x\) s kubiti \(a₁,…,aₚ\).

\subsubsection*{Inicializacija kubita}
Izraz \(\new{a}{t}\) interpretiramo, kot da najprej kubit \(a\) nastavimo na \(\ket{\mb0}\) in nato izvedemo \(t\). Spremenljivka \(a\) je v izrazu \(t\) prosta, v izrazu \(\new{a}{t}\) pa vezana.
% \(\new{a}{}\) se obnaša podobno kot \(∀a.\), \(∃a.\), ali \(λa.\);
% karkoli je po piki (do zaklepaja ali enačaja) vzame kot del izraza \(t\).
% Izraz \(t\) je lahko poljuben izraz s prostim kubitom \(a\), \(\new{a}{t}\) pa interpretiramo, kot da najprej kubit \(a\) nastavimo na \(\ket{\mb0}\) in nato izvedemo \(t\).

\subsubsection*{Uporaba vrat}
V zapisu \(\apply{U}{\oldvec{a}}{t}\) je \(\oldvec{a}\) nek vektor kubitov, ki ga bomo pisali kot \(a₁,…,aₚ\), kjer so \(aᵢ\) posamezni kubiti.
Izraz \(\apply{U}{\oldvec a}{t}\) predstavlja uporabo vrat \(U\) na kubitih \(\oldvec a\), ki jim sledi nadaljevanje \(t\).

\subsubsection*{Meritev}
Izraz \(\measure{a}{t₀}{t₁}\) izmeri kubit \(a\), in nato glede na rezultat nadaljuje z izvajanjem bodisi \(t₀\) bodisi \(t₁\), glede na rezultat meritve. To bo uničilo kubit, torej ga v nadaljevanju ne smemo uporabiti.
Če je kubit del prepletenega stanja, moramo to meritev interpretirati ustrezno z definicijo meritve vektorja na primernem mestu.

% \subsubsection*{Uničenje}
% Ker je uničenje zgolj okrajšava za meritev, po kateri nadaljujemo na isti način ne glede na rezultat, upošteva vsa gornja pravila.

% \subsubsection*{Lambda abstrakcija}
% Lambda abstrakcijo bomo uporabili za tvorjenje operacij na nadaljevanjih (recimo primera \ref{ex:5} in \ref{ex:6} spodaj).

\subsection{Primeri}
Naj \(t\) in \(u\) predstavljata poljubna izraza v jeziku, \(x\) pa naj bo nadaljevanje, ki pričakuje primerno količino kubitov.
\begin{example*}\label{ex:1}
    Definiramo lahko analog izrazu \(ν\), ki kubit nastavi na \(\ket{\mb1}\) namesto \(\ket{\mb0}\):
    \[ \new{₁a}{t} ≔ \new{a}{\apply{X}{a}{t}}. \]
    Izraz \(ν\) lahko potem označimo tudi z \(ν₀\). 
\end{example*}

\begin{example*}\label{ex:2}
    S kvantnimi operacijami lahko modeliramo naključnost; definirajmo funkcijo \(\op{rand}\), ki naključno izbere eno od nadaljevanj:
    \[ \op{rand}{\p{t, u}} ≔ \new{a}{\apply{\had}{a}{\measure{a}{t}{u}}}. \]
\end{example*}

\begin{example*}\label{ex:3}
    Bellovo stanje \(ρ\p{\ket{\mb{00}} + \ket{\mb{11}}}\) lahko programu \(x\) podamo tako:
    \[ \op{bell}{\p{x}} ≔ \new{a}{\new{b}{\apply{\had}{a}{\apply{\ctl X}{a,b}{x(a,b)}}}}. \]
\end{example*}

\begin{example*}\label{ex:4}
    Kljub temu, da velja izrek o neizbrisu, lahko vseeno definiramo operacijo \(\op{disc}\):
    \[ \discard{a}{t} ≔ \measure{a}{t}{t}, \]
    ki kubit uniči tako, da ga izmeri in nato pozabi rezultat meritve.
\end{example*}

\begin{example*}\label{ex:5}
    Oglejmo si zdaj še primera \ref{ex:proj-z} in \ref{ex:c-rot} iz prejšnjega razdelka, najprej projekcijo na \(z\)-os:
    \[ \op{proj}{\p{a;\,x}} ≔ \measurebr{a}{\new{₀a}{x(a)}}{\new{₁a}{x(a)}}. \]
\end{example*}

\begin{example*}\label{ex:6}
    Drugi primer je bil naključna rotacija faze. Uporabimo primer \ref{ex:2}:
    \[ \op{c-rot}{\p{a;\,x}} ≔ \op{rand}{\p{x(a), \apply{Z}{a}{x(a)}}}. \]
\end{example*}

% \subsection{Teorija tipov}
% Sistem tipov se v programske jezike pogosto uvede zaradi večje varnosti;
% preprečijo namreč pisanje veliko nesmiselnih programov.
% Pri nas pa tipi opravljajo še dodatno funkcijo:
% skrbijo, da spremenljivke uporabljamo \airquotes{linearno}.
% To je prednost uporabe linearne teorije tipov namesto navadne teorije tipov za formalizacijo kvantnega računalništva.

\subsection{Linearnost}
Želimo se izogniti nesmiselnim izrazom, torej izrazom, ki ne predstavljajo nobenega dejanskega programa, ki ga lahko izvedemo.
% Ker iz izreka~\ref{th:no-cloning} vemo, da lahko kubite uporabimo zgolj enkrat, upoštevati moramo tudi to.
Upoštevati moramo recimo, da lahko kubite uporabimo zgolj enkrat, kot smo videli v izreku~\ref{th:no-cloning}.

Kot \emph{linearnost} razumemo pogoj, da se vsako hipotezo (rečemo tudi parameter, argument, predpostavko, surovino, …) uporabi natanko enkrat.
Linearna logika nam torej formalizira razne procese, kjer iz ene stvari \airquotes{naredimo} drugo, in s tem prvo stvar \airquotes{porabimo}.
Na linearno logiko lahko tudi gledamo kot semantiko \airquotes{iger} ali \airquotes{interakcij}.
Še bolj pomembno pa je, da na linearno logiko lahko gledamo kot \airquotes{pravo} obliko kvantne logike~\cite{nlab:linear_logic-ql},
ki nam pa dopušča tudi bistveno večjo splošnost.
Že iz imena lahko sklepamo, da se kvantna logika uporablja namesto klasične logike prav tako, kot se kvantna fizika uporablja namesto klasične fizike~\cite{nlab:quantum_logic}.

Vemo, da lahko kubite uporabimo največ enkrat, neuporabljene kubite pa lahko na koncu preprosto izmerimo kot v~\ref{ex:4}, torej lahko rečemo, da kubite uporabimo natanko enkrat.
To je natanko pogoj linearnosti.
Uporaba vrat je res linearna, saj deluje na vseh vhodnih kubitih, do njihove stare vrednosti pa ne moremo več dostopati.
Prav tako je tudi meritev linearna, saj porabi en kubit, ki ga nato ne moremo več uporabljati.
Ker sta to edina načina s katerimi lahko vplivamo na stanja (obstoječih) kubitov, bodo tudi vse funkcije na kubitih linearne.
% Če torej iz linearne logike izpeljemo t.i. linearno teorijo tipov, se pogoj linearnosti naravno pretvori v pogoj, da moramo vsak argument funkciji uporabiti natanko enkrat, kar je natanko to, kar za funkcije na kubitih v fiziki res velja.
% Ker pogoj linearnosti ne velja za klasične bite (te lahko kopiramo, kolikor hočemo) bomo rekli, da so naše funkcije linearne le na \airquotes{kvantnih tipih}.

Podrobnejšo definicijo linearne logike si lahko ogledate v~\cite{girard-linear-logic-1987,girard-linear-logic-1995, nlab:linear_logic}.
Omenimo zgolj, da je del linearne logike, ki ga potrebujemo imenovan multiplikativna intuitionistična linearna logika, ki pa vsebuje zgolj simbole \(⊗\), \(\mb1\), in \(⊸\).

% \subsubsection{Sistem tipov}
% Naš sistem tipov zgradimo iz dela linearne logike imenovanega multiplikativna intuitionistična linearna logika.
% Ta vsebuje zgolj tri simbole \(⊗, \mb1, ⊸\), katerim bomo pa dodali še eno konstanto (kubite).

% Pripadajoče tipe lahko potem zgradimo s sledečimi konstruktorji:
% \begin{table}[H]
% \vspace{-1em}
% \begin{align*}
%     A,B ∷=&\ \unit                                      && \text{tip z enim elementom } ()\\
%       \mid&\ \qbit                                      && \text{tip kubitov}\\
%       \mid&\ A⊗B                                        && \text{tenzorski produkt}\\
%       \mid&\ A ⊸ B                                      && \text{funkcijski tip}
% \end{align*}
% \vspace{-1em}
% \caption{Sistem tipov}
% \end{table}
% \begin{remark}
%     Edini možni tipi v našem jeziku so \(\qbit^{⊗n}\) ali \(\qbit^{⊗m} ⊸ \qbit^{⊗n}\), kjer sta \(m,n ∈ ℕ\) poljubna.
%     To sledi iz enakosti \(A ⊸ (B ⊸ C) = A⊗B ⊸ C\).
%     Tipi oblike \((A ⊸ B) ⊸ C\) so sicer veljavni, vendar elementov teh tipov v našem jeziku ne moremo tvoriti.
% \end{remark}
% \begin{remark}
%     Ker je \(\unit\) enota za tenzorski produkt, velja \(\qbit^{⊗0} = \unit\).
% \end{remark}

\begin{definition}
    Naj zapis oblike \(\sequent{Γ}{Δ}{t}\) pomeni, da je \emph{\(t\) izraz v kontekstu \(Γ \mid Δ\)}, kjer \(Δ\) predstavlja seznam parametrov, \(Γ\) pa seznam računskih spremenljivk, označenih s številom parametrov.

    % V našem primeru, bomo za \(Γ\) pisali \(x₁:m₁,…,xₖ:mₖ \mid a₁,…,aₚ\),
    % kjer so \(xᵢ\) nadaljevanja (oziroma računske spremenljivke) tipa \(\qbit^{⊗mᵢ} ⊸ Aᵢ\), \(aᵢ\) pa kubiti (torej tipa \(\qbit\)).
\end{definition}

Pravila za določitev veljavnosti izrazov našega jezika so torej takšna:
%LTeX: enabled=false
\begin{table}[H]
\begin{mathpar}
    \inferrule
        {(x:m)∈Γ}
        {\sequent{Γ}{a₁,…,aₘ}{x(a₁,…,aₘ)}}
    \and
    \inferrule
        {\sequent{Γ}{a₁,…,aₚ}{t}}
        {\sequent{Γ}{a_{σ(1)},…,a_{σ(p)}}{t}}
    \p{σ ∈ Sₚ}
    \and
    \inferrule
        {\sequent{Γ}{Δ,a}{        t }}
        {\sequent{Γ}{Δ  }{\new{a}{t}}}
    \and
    \inferrule
        {\sequent{Γ}{Δ,\oldvec{a}}{                      t } \\ U ∈ \U[|\oldvec a|]}
        {\sequent{Γ}{Δ,\oldvec{a}}{\apply{U}{\oldvec{a}}{t}}}
    \and
    \inferrule
        {\sequent{Γ}{Δ}{t₀}\\
         \sequent{Γ}{Δ}{t₁}}
        {\sequent{Γ}{Δ, a}{\measure{a}{t₀}{t₁}}}
    % \and
    % \inferrule
    %     {\sequent{Γ}{Δ  }{            t }}
    %     {\sequent{Γ}{Δ,a}{\discard{a}{t}}}
\end{mathpar}
\caption{Pravila za veljavnost izrazov}
\end{table}
%LTeX: enabled=true

Linearnost programov nam zagotavljata dve stvari. Prva je, da pri uporabi vrat kubite, na katerih vrata uporabimo zamenjamo z novimi. V pravilu so kubiti \(\oldvec a\) spodaj tisti \emph{pred} uporabo vrat, zgoraj so pa \emph{po} uporabi vrat, tako da ne pride do nobenega podvajanja.
Poleg tega v pravilu meritve kubitov izmerjenega kubita ne moremo uporabiti v podizrazih \(tᵢ\).
Pri dodeljevanju novih kubitov pa moramo zgolj paziti, da kubita \(a\) ni že v \(Δ\) (na kar moramo paziti tudi pri ostalih pravilih).

Druga stvar, ki nam zagotavlja linearnost so pa operacije same. Uporaba vrat do kubitov dostopa zgolj enkrat, ko uporabi vrata na njih. Prav tako meritev dostopa do merjenega kubita zgolj enkrat, ostalih kubitov se pa ne dotakne, dodeljevanje kubitov pa sploh ne uporabi nobenega kubita. Tako so tudi operacije \emph{same} linearne, torej lahko res rečemo, da je naš jezik linearen.

Naš jezik podpira poleg kubitov tudi računske spremenljivke, za katere pa ne zahtevamo linearnosti, saj so zgolj sintaktični element, ki nam predstavlja nek neznan program, za katerega lahko zamenjamo poljuben izraz v jeziku.

\begin{example}
    Izpeljimo veljavnost izraza iz primera~\ref{ex:1}.
    %LTeX: enabled=false
    \[  \inferrule
        {\inferrule
        {\inferrule
            { }
            {\sequent{x:1}{a}{x(a)}}}
            {\sequent{x:1}{a}{\apply{X}{a}{x(a)}}}}
            {\sequent{x:1}{-}{\new{a}{\apply{X}{a}{x(a)}}}}\qedhere\]
    %LTeX: enabled=true
\end{example}

\subsection{Aksiomi}
%TODO: intro
% matija: Tu bi dodal še malo uvoda, torej. Kvantno računalništvo bomo opisali z enačbami med dvema izrazoma, ki sta veljavna v istem kontekstu. Mogoče ne bi bilo slabo aksiomov opremiti s kontekstom, da se ga malo navadimo.
Izkaže se, da je nabor aksiomov, ki jih potrebujemo za polno karakterizacijo kvantnih programov relativno majhen: potrebujemo jih zgolj \(12\) in kot bomo videli nismo žrtvovali preprostosti, da smo prišli do te številke.

Aksiome za enakost programov~\cite{algeff-lin-qpl} lahko delimo na dva dela: prvih pet je glavnih, ostalih sedem pa bolj \airquotes{administrativnih} oziroma pomožnih.
Slednji nam povejo zgolj, da se uporaba vrat strinja s strukturo unitarnih matrik,
ter da operacije komutirajo, kolikor vezava spremenljivk (in vrstni red uporabe matrik) dopušča.

\begin{axiom}{Kvantna negacija pred meritvijo je negacija po meritvi:}\label{ax:A}
    \( \apply{X}{a}{\measure{a}{x}{y}} = \measure{a}{y}{x} \).
\end{axiom}

\begin{axiom}{Kvantna kontrola je po meritvi kot klasična kontrola:}\label{ax:B}
    \( \applyd{U, V}{a,b}{\measure{a}{x(b)}{y(b)}}
       = \measurebr{a}{\apply{U}{b}{x(b)}}{\apply{V}{b}{y(b)}} \).
\end{axiom}

\begin{axiom}{Kvantna vrata uporabljena na zavrženih kubitih so odveč:}\label{ax:C}
    \( \apply{U}{a}{\discard{a}{t}} = \discard{a}{t} \).
\end{axiom}

\begin{axiom}{Novi kubiti so \( \ket{\mb0} \) glede na meritev:}\label{ax:D}
    \( \new{a}{\measure{a}{x}{y}} = x \).
\end{axiom}

\begin{axiom}{Novi kubiti so \( \ket{\mb0} \) glede na kontrolo:}\label{ax:E}
    \( \new{a}{\applyd{U,V}{a,b}{x{\p{a,b}}}} = \apply{U}{b}{\new{a}{x{\p{a,b}}}} \).
\end{axiom}

\begin{axiom}{Spoštovanje simetrične grupe \( \U[n] \):}\label{ax:F}
    \( \apply{swap}{a,b}{x{\p{a,b}}} = x{\p{b,a}} \),
\end{axiom}

\begin{axiom}{}\label{ax:G}
    \( \apply{I}{a}{x{\p a}} = x{\p a} \),
\end{axiom}

\begin{axiom}{}\label{ax:H}
    \( \apply{UV}{a}{x{\p a}} = \apply{V}{a}{\apply{U}{a}{x{\p a}}} \),
\end{axiom}

\begin{axiom}{}\label{ax:I}
    \( \apply{(U⊗V)}{a,b}{x{\p{a,b}}} = \apply{U}{a}{\apply{V}{b}{x{\p{a,b}}}} \).
\end{axiom}

\begin{axiom}{Komutativnost:}\label{ax:J}
    \( \measurebr{a}{\measure{b}{u}{v}}{\measure{b}{x}{y}}
       = \measurebr{b}{\measure{a}{u}{x}}{\measure{a}{v}{y}} \),
\end{axiom}

\begin{axiom}{}\label{ax:K}
    \( \new{a}{\new{b}{x{\p{a,b}}}} = \new{b}{\new{a}{x{\p{a,b}}}} \),
\end{axiom}

\begin{axiom}{}\label{ax:L}
    \( \new{a}{\measure{b}{x{\p a}}{y{\p a}}} = \measurebr{b}{\new{a}{x{\p a}}}{\new{a}{y{\p a}}} \).
\end{axiom}

Uporabimo sedaj zgornje aksiome, da dokažemo, da sta primera \ref{ex:5} in \ref{ex:6} dejansko enaka.
V dokazu bomo poleg aksiomov uporabili še dve enakosti matrik, \(\ctl{X}⋅\swap⋅\ctl{X} \stackrel{(*)}{=} \swap⋅\ctl{X}⋅\swap\) in \(\swap⋅\ctl{X}⋅\swap \stackrel{(†)}{=} (\had⊗I)⋅\ctl{Z}⋅(\had⊗I)\).

\begin{align*}
     &\ \measurebr{b}{\new{a}{x(a)}}{\new{a}{\apply{X}{a}{x(a)}}}               &\\
    =&\ \new{a}{\measure{b}{x(a)}{\apply{X}{a}{x(a)}}}                          &(\ref{ax:L})\\
    =&\ \new{a}{\apply{\ctl X}{b,a}{\measure{b}{x(a)}{x(a)}}}                   &(\ref{ax:B})\\
    =&\ \new{a}{\apply{\ctl X}{b,a}{\discard{b}{x(a)}}}                         &(\text{def.})\\
    =&\ \new{a}{\apply{\ctl X}{a,b}{\apply{\ctl X}{b,a}{\discard{a}{x(b)}}}}    &(*)\\
    =&\ \new{a}{\apply{\ctl X}{b,a}{\discard{a}{x(b)}}}                         &(\ref{ax:E})\\
    =&\ \new{a}{\apply{\had}{a}{\apply{\ctl Z}{a,b}{\apply{\had}{a}{\discard{a}{x(b)}}}}}&(†)\\
    =&\ \new{a}{\apply{\had}{a}{\apply{\ctl Z}{a,b}{\discard{a}{x(b)}}}}        &(\ref{ax:C})\\
    =&\ \new{a}{\apply{\had}{a}{\measure{a}{x(b)}{\apply{Z}{b}{x(b)}}}}         &(\ref{ax:B})
\end{align*}

Kasneje bomo to enakost preverili še z algebrajsko teorijo.
