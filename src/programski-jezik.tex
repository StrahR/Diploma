\section{Programski jezik}

\subsection{Sintaksa}

Poznamo sledeče sintaktične elemente:\\
%LTeX: enabled=false
% \begin{tabular}{r l l}%imperative version
%     izračun \(c\) \(::=\)& \(b, q, x, …\)                                     & spremenljivke\\
%                  \(\mid\)& \qpl{true} \(\mid\) \qpl{false}
%                  \(\mid\) \(\ket{\mb0}\) \(\mid\) \(\ket{\mb1}\)              & konstante\\
%                  \(\mid\)& \qpl{|\(b≔\)| true} \(\mid\) \qpl{|\(b≔\)| false}  & inicializacija bita\\
%                  \(\mid\)& \qpl{|\(\enew{q}\)|}                               & inicializacija kubita\\
%                  \(\mid\)& \qpl{|\(\emeasure{q}\)|}                           & meritev\\
%                  \(\mid\)& \qpl{|\(\ediscard{q}\)|}                           & uničenje\\
%                  \(\mid\)& \qpl{|\(\eapply{U}{q}\)|}                          & uporaba vrat\\
%                  \(\mid\)& \qpl{fun |\(f\)| |\((x₁ : A₁, …, xₚ : Aₚ) ↦ c\)|} & funkcija\\
%                  \(\mid\)& \qpl{if |\(b\)| then |\(c₁\)| else |\(c₂\)|}       & pogojni stavek\\
%                  \(\mid\)& \(f{\p{c₁,…,cₚ}}\)                                 & uporaba funkcije\\
%                 %  \(\mid\)& \qpl{let |\(x ← c₁\)| in |\(c₂\)|}                 & vezava\\
%                  \(\mid\)& \qpl{|\(x ≔ c\)|}                                  & vezava\\
%                  \(\mid\)& \qpl{|\(c₁\)|;|\(c₂\)|}                            & veriženje\\
%                  \(\mid\)& \qpl{|\(x,y\)|}                                    & sestavitev vektorjev\\
%                 %  \(\mid\)& \qpl{let |\((q₁,…,qₚ) ← y\)| in |\(c\)|}           & razcep vektorja\\
%                  \(\mid\)& \qpl{|\((q₁,…,qₚ) ≔ y\)|}                          & razcep vektorja\\
%                  \(\mid\)& \qpl{{|\(c\)|}}                                    & blok\\
% \end{tabular}
\begin{tabular}{r l l}
    izračun \(c\) \(::=\)& \(x\)                                              & spremenljivke\\
                 \(\mid\)& \(()\) % \(\mid\) \qpl{true} \(\mid\) \qpl{false}
                 \(\mid\) \(\ket{\mb0}\) \(\mid\) \(\ket{\mb1}\)              & konstante\\
                %  \(\mid\)& \qpl{|\(b≔\)| true} \(\mid\) \qpl{|\(b≔\)| false}  & inicializacija bita\\
                 \(\mid\)& \qpl{|\(\enew\)|}                                  & inicializacija kubita\\
                 \(\mid\)& \qpl{|\(\emeasure{x}\)|}                           & meritev kubita\\
                 \(\mid\)& \qpl{|\(\ediscard{x}\)|}                           & uničenje kubita\\
                 \(\mid\)& \qpl{|\(\eapply{U}{x}\)|}                          & uporaba vrat\\
                 \(\mid\)& \qpl{|\(xᵢ\)|}                                     & naslavljanje kubita\\
                 \(\mid\)& \qpl{(|\(x₁,…,xₚ\)|)}                              & pridružitev kubitov\\
                %  \(\mid\)& \(\eff{op}{\p q}\)                                 & operacija\\
                 \(\mid\)& \qpl{fun |\(f(x : A) ↦ c\)|}                      & funkcija\\
                 \(\mid\)& \(f{\p c}\)                                        & uporaba funkcije\\
                 \(\mid\)& \qpl{if |\(c\)| then |\(c₁\)| else |\(c₂\)|}       & pogojni stavek\\
                 \(\mid\)& \qpl{let |\(x ← c₁\)| in |\(c₂\)|}                 & vezava in veriženje\\
                %  \(\mid\)& \qpl{|\(x ≔ c\)|}                                  & vezava\\
                %  \(\mid\)& \qpl{|\(c₁\)|;|\(c₂\)|}                            & veriženje\\
                %  \(\mid\)& \qpl{let |\((q₁,…,qₚ) ← y\)| in |\(c\)|}           & razcep vektorja\\
                %  \(\mid\)& \qpl{|\((q₁,…,qₚ) ≔ y\)|}                          & razcep vektorja\\
                %  \(\mid\)& \qpl{(|\(c\)|)}                                    & blok\\
\end{tabular}
%LTeX: enabled=true

\subsubsection*{Vezava in veriženje}
V \qpl{let |\(x ← c₁\)| in |\(c₂\)|} najprej izračunamo \(c₁\), rezultat shranimo v spremenljivko \(x\), in nadaljujemo z izvajanjem \(c₂\). Če se \(x\) ne pojavi v \(c₂\) (razen v kaki drugi vezavi) lahko zapis okrajšamo na \qpl{|\(c₁\)|;|\(c₂\)|}.

\subsubsection*{Naslavljanje in pridružitev kubitov}
Na vsak kvantni vektor reda \(n\) lahko gledamo kot \(n\) prepletenih kubitov, tako da je ta zapis smiseln.
Dopuščali bomo, da se pridruženi kubiti pojavijo na mestih, kjer pričakujemo vektor, kot na primer v vezavi (\qpl{let |\((x₁,…,xₙ) ← c₁\)| in |\(c₂\)|}) ali pri uporabi vrat (\(\eapply{U}{x₁,…,xₙ}\)).
Dvojne oklepaje opuščamo.


\subsubsection*{Funkcije}
Glede na obliko tipa \(A\) lahko definiramo nekaj okrajšav:
\begin{itemize}
    \item Če je \(A = \unit\) pišemo \qpl{fun |\(f() ↦ c\)|}.
    \item Če je \(A\) produkt, ga razpišemo kot \qpl{fun |\(f(x₁ : A₁, …, xₙ : Aₙ) ↦ c\)|}.
\end{itemize}
Če funkcije ne želimo poimenovati lahko \(f\) tudi kar izpustimo.

% Če je \(A\) oblike \(⨂ᵢAᵢ\) pišemo tudi \qpl{fun |\(f(x₁ : A₁, …, xₙ : Aₙ) ↦ c\)|},
% če je pa \(A\) oblike \(B×Q\) pa pišemo \qpl{fun |\(f(b : B, x : Q) ↦ c\)|}.

\subsubsection*{Inicializacija kubita}
Dodeli nov kubit in ga vrne. Ta kubit bo enak \(\ket{\mb0}\).
Definiramo lahko tudi operacijo \(\eff{new}¹()\), inicializira kubit na \(\ket{\mb1}\).

\subsubsection*{Uporaba vrat}
Vrata \(U\) morajo biti primerne velikosti, da jih lahko uporabimo na danem vektorju.
Uporabi vrata \(U\) na danem vektorju.

\subsubsection*{Meritev}
Izmeri dani kubit in vrne rezultat meritve. To bo uničilo kubit, torej ga v nadaljevanju ne smemo uporabiti.
Če je meritev oblike \(\emeasure{xᵢ}\), je meritev, ki jo izvedemo \(Mᵢ(x)\), in se vektor \(x\) spremeni skladno z definicijo meritve vektorja.
Enako velja tudi, če meritev ni te oblike, vendar dani kubit naslavlja del vektorja.

\subsubsection*{Uničenje kubita}
Uničenje je zgolj okrajšava za meritev, katere rezultat pozabimo, tako da upošteva vsa gornja pravila.
%TODO: če po meritivi pozabimo na rezultat ostanemo v mešanem stanju, omeni to pri meritvi

\subsection{Primeri}
\begin{example*}\label{ex:1}
    Zgoraj smo omenili operacijo \(\eff{new}¹()\). Definiramo jo lahko znotraj jezika:
    \begin{center}
        \qpl{fun |\(\eff{new}¹() ↦ \eapply{X}{\enew}\)|}
    \end{center}
    Operacijo \(\enew\) lahko potem označimo tudi z \(\eff{new}₀()\). 
\end{example*}

\begin{example*}\label{ex:2}
    S kvantnimi operacijami lahko modeliramo naključnost; definirajmo funkcijo \texttt{rand}, ki naključno vrne \(0\) ali \(1\):
    \begin{center}
        \qpl{fun |\(\eff{rand}() ↦ \emeasure{\eapply{\had}{\enew}}\)|}
    \end{center}
\end{example*}

\begin{example*}\label{ex:3}
    Bellovo stanje \(\state{\ket{\mb{00}} + \ket{\mb{11}}}\) lahko definiramo tako:
    \begin{center}
        \(\eff{apply}_{\ctl X}{\p{\eapply{\had}{\enew}, \enew}}\)
    \end{center}
\end{example*}

\begin{example*}\label{ex:4}
    Kot v prvem primeru, bi tudi operacijo \(\eff{discard}\) lahko definirali izključno znotraj jezika:
    \begin{center}
        \qpl{fun |\(\eff{discard}\p{q : \qbit} ↦\) let \(x ← \emeasure{q}\) in \(()\)|}
    \end{center}
    Tu \(()\) predstavlja edini element tipa \(\unit\).
    Izkaže se, da je ta operacija bolj pomembna kot primer \ref{ex:1}, tako da jo vključimo neposredno v sintakso jezika.
\end{example*}

\begin{example*}\label{ex:5}
    Oglejmo si zdaj še prejšnja dva primera, najprej projekcijo na \(z\)-os:
    \begin{center}
        \qpl{fun |\(\eff{proj}(q : \qbit) ↦ \)| if |\(\emeasure{q}\)| then |\(\eff{new}₁()\)| else |\(\eff{new}₀()\)|}
    \end{center}
\end{example*}

\begin{example*}\label{ex:6}
    Drugi primer je bil naključna rotacija faze. Uporabimo primer \ref{ex:2}:
    \begin{center}
        \qpl{fun |\(\eff{rot}(q : \qbit) ↦ \)| if |\(\eff{rand}()\)| then |\(\eapply{Z}{q}\)| else |\(q\)|}
    \end{center}
\end{example*}


\subsection{Teorija tipov}

Tipe ločimo na dve vrsti, klasične in kvantne:\\
\begin{tabular}{r l l}%TODO: format
    klasični \(B\) \(::=\)& \(\type{0}\) \(\mid\) \(\unit\)                & osnovni klasični tipi\\
                  \(\mid\)& \(B₁+B₂\)                                      & vsota\\
                  \(\mid\)& \(B₁×B₂\)                                      & kartezični produkt\\
                  \(\mid\)& \(A₁ → A₂\)                                    & funkcijski tip\\
    kvantni \(Q\) \(::=\)&  \(\qbit\)                                      & tip kubitov\\
                 \(\mid\)&  \(Q₁⊗Q₂\)                                     & tenzorski produkt\\
    splošni \(A\) \(::=\)&  \(B\) \(\mid\) \(Q\)                           & ostali tipi\\
                 \(\mid\)&  \((B,Q)\)                                      & splošen produkt\\
\end{tabular}
\begin{remark}
    % Kvantni tipi so natanko kvantni vektorji, 
    % Tenzorski produkt med kvantnimi tipi je definiran kot navaden tenzorski produkt vektorjev,
    Splošen produkt razumemo kot kartezičen produkt.
    Definiramo lahko tudi operacije s splošnim produktom:
    \begin{align*}
        B₁+(B,Q) &≔ (B₁+B,Q)\\
        B₁×(B,Q) &≔ (B₁×B,Q)\\
        Q₁⊗(B,Q) &≔ (B,Q₁⊗Q)
    \end{align*}
    Prvi komponenti splošnega produkta pravimo klasična, drugi pa kvantna.
    V nadaljevanju, ko se nanašamo na kvantne in klasične tipe, mislimo tudi na ustrezne komponente splošnega produkta.
\end{remark}

\begin{definition}
    Označimo \(\bit ≔ \unit + \unit\) in \qpl{true} \(≔ ι₁()\), \qpl{false} \(≔ ι₂()\).
\end{definition}

\subsubsection{Linearnost}
Kot linearnost razumemo pogoj, da se vsako hipotezo (tudi parameter, argument, predpostavko, surovino)
uporabi natanko enkrat.
Linearna logika nam torej formalizira razne procese, kjer iz ene stvari \airquotes{naredimo} drugo, in s tem prvo stvar \airquotes{porabimo}.
Če potem iz linearne logike izpeljemo tako imenovano linearno teorijo tipov, se ta pogoj linearnosti naravno pretvori v pogoj, da moramo vsak argument funkciji uporabiti natanko enkrat.

Spomnimo se, da z unitarnimi transformacijami (kvantnimi vrati) kubitov ne moremo niti klonirati, niti uničiti.
To je pa ravno pogoj linearnosti!
Pravimo, da je operacija \(\eff{apply}_{\g U}\) linearna, saj ohranja število kubitov.
Poleg tega je tudi meritev linearna, saj porabi en kubit, ki ga nato ne moremo več uporabljati.
Ker sta to edina načina s katerimi lahko vplivamo na stanja kubitov, morajo biti vse funkcije na kubitih tudi linearne.
Ker pogoj linearnosti ne velja za klasične bite (te lahko kopiramo, kolikor hočemo) bomo rekli, da so funkcije linearne le na kvantnih tipih.

%TODO: cite nlab+girard "Za natančno definicijo linearne logike si oglejte…"
% Definiramo fragment linearne logike s sledečimi simboli: \(⊗, +, 0, 1, ⊸, !\).

%TODO: subsubseciton
\begin{definition}
    Kontekst naj bo seznam dodelitev tipov spremenljivkam.
\end{definition}

\begin{definition}
    Zapis oblike \(\sseq{Γ}{x : A}\) pomeni, da ima \(x\) tip \(A\) v kontekstu \(Γ\).
\end{definition}

%TODO: format
%LTeX: enabled=false
\begin{prooftree}[center=false]
    \hypo{(x : A) ∈ Γ}
  \infer1{\sseq{Γ}{x : A}}
\end{prooftree}\quad
\begin{prooftree}[center=false]
  \infer0{\sseq{Γ}{() : \unit}}
\end{prooftree}\quad
% \begin{prooftree}[center=false]
%   \infer0{\sseq{Γ}{\qpl{true}: \bit}}
% \end{prooftree}\quad
% \begin{prooftree}[center=false]
%   \infer0{\sseq{Γ}{\qpl{false}: \bit}}
% \end{prooftree}\quad
\begin{prooftree}[center=false]
  \infer0{\sseq{Γ}{\ket{\mb0} : \qbit}}
\end{prooftree}\quad
\begin{prooftree}[center=false]
  \infer0{\sseq{Γ}{\ket{\mb1} : \qbit}}
\end{prooftree}\\
\begin{prooftree}[center=false]
  \infer0{\sseq{Γ}{\eff{new} : \unit → \qbit}}
\end{prooftree}\quad
\begin{prooftree}[center=false]
  \infer0{\sseq{Γ}{\eff{measure} : \qbit → \bit}}
\end{prooftree}\quad
\begin{prooftree}[center=false]
  \infer0{\sseq{Γ}{\eff{discard} : \qbit → \unit}}
\end{prooftree}\\
\begin{prooftree}[center=false]
    \hypo{n ∈ ℕ}
    \hypo{U ∈ \U[n]}
  \infer2{\sseq{Γ}{\eff{apply}_{\g U} : \qbit^{⊗n} → \qbit^{⊗n}}}
\end{prooftree}\\
\begin{prooftree}[center=false]
    \hypo{\sseq{Γ}{x : \qbit^{⊗n}}}
    \hypo{i ∈ {1,…,n}}
  \infer2{\sseq{Γ}{xᵢ : \qbit}}
\end{prooftree}\quad
\begin{prooftree}[center=false]
    \hypo{\for{i ∈ {1,…,n}}{\p{\sseq{Γ}{xᵢ : \qbit}}}}
  \infer1{\sseq{Γ}{(x₁,…,xₙ) : \qbit^{⊗n}}}
\end{prooftree}\\
\begin{prooftree}[center=false]
    \hypo{\sseq{Γ, x : A}{c : B}}
  \infer1{\sseq{Γ       }{\qpl{fun |\((x : A) ↦ c\)|} : A → B}}
\end{prooftree}\quad
\begin{prooftree}[center=false]
    \hypo{\sseq{Γ}{f : A → B}}
    \hypo{\sseq{Γ}{c : A}}
  \infer2{\sseq{Γ}{f{\p c} : B}}
\end{prooftree}\\
\begin{prooftree}[center=false]
    \hypo{\sseq{Γ}{c : \bit}}
    \hypo{\sseq{Γ}{c₁ : A}}
    \hypo{\sseq{Γ}{c₂ : A}}
  \infer3{\sseq{Γ}{\qpl{if |\(c\)| then |\(c₁\)| else |\(c₂\)|} : A}}
\end{prooftree}\quad
\begin{prooftree}[center=false]
    \hypo{\sseq{Γ       }{c₁ : A}}
    \hypo{\sseq{Γ, x : A}{c₂ : B}}
  \infer2{\sseq{Γ       }{\qpl{let |\(x ← c₁\)| in |\(c₂\)|} : B}}
\end{prooftree}
%LTeX: enabled=true

\subsection{Interpretacija z algebrajskimi izrazi}

Da lahko naše operacije lažje interpretiramo kot algebrajske izraze, jih bomo zapisali v obliki z nadaljevanji.
Naj bo \(\op{op}\) neka operacija, ki se lahko nadaljuje na \(k\) načinov. Nadaljevanja označimo s \(tᵢ\), vsako od njih pa naj tudi pričakuje nekaj parametrov (in za preprostost naj vsa pričakujejo enako število parametrov \(m\)). To zapišemo kot \(b₁,…,bₘ.tᵢ\).
Če operacija sama zahteva \(p\) parametrov, jo pišemo kot \(\op{op}{\p{a₁,…,aₚ; b₁,…,bₘ.t₁,…,b₁,…,bₘ.tₖ}}\).

Če se osredotočimo zgolj na kompleksni del jezika, torej, če pozabimo na vse klasične konstrukte, lahko definiramo konstruktorje za algebrajske izraze:
\begin{itemize}
    \item če je \(t\) izraz, ki pričakuje kubit \(a\), potem obstaja izraz \(\tnew{a}{t}\),
    ki dodeli nov kubit in ga shrani v \(a\), nato pa nadaljuje s \(t\),
    \item če je \(t\) izraz, ki pričakuje kubite \(b₁,…,bₙ\) in so \(a₁,…,aₙ\) kubiti ter \(U\) unitarna vrata reda \(n\), potem obstaja izraz \(\cmd{apply}_{\g U}{\p{a₁,…,aₙ;\, b₁,…,bₙ.\,t}}\), ki najprej uporabi vrata \(U\) na kubitih \(a₁,…,aₙ\), nato pa shrani rezultat v \(b₁,…,bₙ\) in nadaljuje s \(t\). Ta operacija uniči kubite \(aᵢ\), tako da lahko nadaljevanje spet veže kubite \(aᵢ\) namesto \(bᵢ\) in bomo pisali kar \(\tapply{U}{a₁,…,aₙ}{t}\),
    \item če sta \(t\) in \(u\) izraza, in je \(a\) kubit, potem obstaja izraz \(\tmeasure{a}{t}{u}\), ki izmeri \(a\) in nadaljuje v \(t\), če izmeri\(0\) in v \(u\), če izmeri \(1\). Ta operacija je linearna, torej \(t\) in \(u\) ne smeta uporabiti kubita \(a\); tega namreč meritev uniči,
    \item če je \(t\) izraz in \(a\) kubit, potem obstaja izraz \(\tdiscard{a}{t}\), ki zavrže kubit \(a\). Kot zgoraj, \(t\) ne sme uporabiti kubita \(a\),
    \item če je \(x\) neko nadaljevanje, ki pričakuje \(n\) kubitov (oznaka \(x : n\)) in so \(a₁,…,aₙ\) kubiti, je \(x(a₁,…,aₙ)\) izraz na \(n\) kubitih.
\end{itemize}
Čeprav je pogojni stavek klasičen konstrukt, ga v tem formalizmu ne pogrešamo, saj je \(\tmeasure{a}{t}{u}\) ekvivalenten \qpl{if |\(\emeasure{a} = 0\)| then |\(t\)| else |\(u\)|}, funkcije pa lahko razumemo kot poimenovana nadaljevanja.

\begin{examples}
    Oglejmo si zgornje primere zapisane v algebrajskem jeziku:
    \begin{enumerate}
        \item \(\cmd{new}¹(a.t) ≔ \tnew{a}{\tapply{X}{a}{t}}\),
        \item \(\cmd{rand}(a.t) ≔ \tnew{a}{\tapply{\had}{a}{\tmeasure{a}{0}{1}}}\),
        \item \(\tnew{a}{\tnew{b}{\tapply{\had}{a}{\tapply{\ctl{X}}{a,b}{y(a,b)}}}}\),
        \item \(\tdiscard{a}{t} ≔ \tmeasure{a}{t}{t}\),
        \item \(\tmeasure{a}{\tnew{b}{x(b)}}{\tnew{b}{\tapply{X}{b}{x(b)}}}\),
        \item \(\tnew{b}{\tapply{\had}{b}{\tmeasure{b}{x(a)}{\tapply{Z}{a}{x(a)}}}}\).
    \end{enumerate}
    Tu je \(x\) neko poljubno nadaljevanje, ki pričakuje en kubit,
    \(y\) pa nadaljevanje, ki pričakuje dva nova kubita.
    V diagramu bi torej bila \(x\) in \(y\) karkoli je potem po žicah desno na koncu primerov.

    Sicer obnašanje programov ni postalo nič bolj jasno, oziroma je na prvi pogled še težje videti kaj program dela, vendar pa lahko sedaj te izraze manipuliramo kot smo navajeni iz algebre.
    Ampak, da lahko z izrazi sploh karkoli naredimo potrebujemo nekaj enakosti med izbranimi osnovnimi izrazi, oziroma aksiome.
\end{examples}

Na podoben način kot za tipe, lahko zgornja pravila povzamemo z drevesi.
Naj \(\sequent{Γ}{Δ}{t}\) predstavlja, da je \(t\) izraz na kubitih v \(Δ\) v kontekstu \(Γ\),
kjer je tokrat kontekst seznam nadaljevan, skupaj z njihovo členostjo (\(Γ = (x₁ : m₁),…,(xₖ : mₖ)\)).
\[\begin{prooftree}
    \hypo{\sequent{Γ}{Δ, a}{         t }}
  \infer1{\sequent{Γ}{Δ   }{\tnew{a}{t}}}
\end{prooftree}\qquad
\begin{prooftree}
    \hypo{\sequent{Γ}{Δ, a₁, …, aₚ}{              t }}
  \infer1{\sequent{Γ}{Δ, a₁, …, aₚ}{\tapply{U}{a}{t}}}
\end{prooftree}\]
\[\begin{prooftree}
    \hypo{\sequent{Γ}{Δ   }{             t    }}
    \hypo{\sequent{Γ}{Δ   }{                u }}
  \infer2{\sequent{Γ}{Δ, a}{\tmeasure{a}{t}{u}}}
\end{prooftree}\quad
\begin{prooftree}
    \hypo{\sequent{Γ}{Δ           }{             t }}
  \infer1{\sequent{Γ}{Δ, a₁, …, aₚ}{\tdiscard{a}{t}}}
\end{prooftree}\quad
\begin{prooftree}
    \hypo{(x : p) ∈ Γ}
  \infer1{\sequent{Γ}{a₁, …, aₚ}{x(a)}}
\end{prooftree}\]

\subsection{Aksiomi}
Izkaže se, da je nabor aksiomov, ki jih potrebujemo za polno karakterizacijo kvantnih programov majhen: potrebujemo jih \(12\) in kot bomo videli nismo žrtvovali preprostosti, da smo prišli do te številke.

Aksiome za enakost programov\cite{algeff-lin-qpl} lahko delimo na dva dela: prvih pet je glavnih, ostalih sedem pa bolj \airquotes{administrativnih} oziroma pomožnih.
Slednji nam povejo zgolj, da se \(\eff{apply}\) strinja s strukturo unitarnih matrik,
ter da stvari komutirajo, kolikor vezava spremenljivk (in vrstni red uporabe matrik) dopušča.

\begin{axiom}{Kvantna negacija pred meritvijo je negacija po meritvi:}\label{ax:A}
    \( \tapply{X}{a}{\tmeasure{a}{x}{y}} = \tmeasure{a}{y}{x} \).
\end{axiom}

\begin{axiom}{Kvantna kontrola je po meritvi kot klasična kontrola:}\label{ax:B}
    \( \tapplyd{U, V}{a,b}{\tmeasure{a}{x(b)}{y(b)}}\\
       \text{\hspace{7em}} = \tmeasure{a}{\tapply{U}{b}{x(b)}}{\tapply{V}{b}{y(b)}} \).
\end{axiom}

\begin{axiom}{Kvantna vrata uporabljena na zavrženih kubitih so odveč:}\label{ax:C}
    \( \tapply{U}{a}{\tdiscard{a}{t}} = \tdiscard{a}{t} \).
\end{axiom}

% \begin{axiom}{Meritve novih kubitov so vedno \(0\):}\label{ax:4}
\begin{axiom}{Novi kubiti so \( \ket{\mb0} \) glede na meritev:}\label{ax:D}
    \( \tnew{a}{\tmeasure{a}{x}{y}} = x \).
\end{axiom}

% \begin{axiom}{Vrata kontrolirana z novimi kubiti se nikoli ne uporabijo:}\label{ax:E}
\begin{axiom}{Novi kubiti so \( \ket{\mb0} \) glede na kontrolo:}\label{ax:E}
    \( \tnew{a}{\tapplyd{U,V}{a,b}{x{\p{a,b}}}} = \tapply{U}{b}{\tnew{a}{x{\p{a,b}}}} \).
\end{axiom}

\begin{axiom}{Spoštovanje simetrične grupe \( \U[n] \):}\label{ax:F}
    \( \tapply{swap}{a,b}{x{\p{a,b}}} = x{\p{b,a}} \),
\end{axiom}

\begin{axiom}{}\label{ax:G}
    \( \tapply{I}{a}{x{\p a}} = x{\p a} \),
\end{axiom}

\begin{axiom}{}\label{ax:H}
    \( \tapply{UV}{a}{x{\p a}} = \tapply{V}{a}{\tapply{U}{a}{x{\p a}}} \),
\end{axiom}

\begin{axiom}{}\label{ax:I}
    \( \tapply{U⊗V}{a,b}{x{\p{a,b}}} = \tapply{U}{a}{\tapply{V}{b}{x{\p{a,b}}}} \).
\end{axiom}

\begin{axiom}{Komutativnost:}\label{ax:J}
    \( \tmeasure{a}{\tmeasure{b}{u}{v}}{\tmeasure{b}{x}{y}}\\
       \text{\hspace{7em}} = \tmeasure{b}{\tmeasure{a}{u}{x}}{\tmeasure{a}{v}{y}} \),
\end{axiom}

\begin{axiom}{}\label{ax:K}
    \( \tnew{a}{\tnew{b}{x{\p{a,b}}}} = \tnew{b}{\tnew{a}{x{\p{a,b}}}} \),
\end{axiom}

\begin{axiom}{}\label{ax:L}
    \( \tnew{a}{\tmeasure{b}{x{\p a}}{y{\p a}}}\\
       \text{\hspace{7em}} = \tmeasure{b}{\tnew{a}{x{\p a}}}{\tnew{a}{y{\p a}}} \).
\end{axiom}

\subsection{Primeri}
Uporabimo sedaj zgornje aksiome, da dokažemo, da sta primera \ref{ex:5} in \ref{ex:6} dejansko enaka.

V dokazu bomo poleg aksiomov uporabili dve enakosti matrik, \(\ctl{X}⋅\swap⋅\ctl{X} \stackrel{(*)}{=} \swap⋅\ctl{X}⋅\swap\) in \(\swap⋅\ctl{X}⋅\swap \stackrel{(†)}{=} (\had⊗I)⋅\ctl{Z}⋅(\had⊗I)\).

% \begin{align*}
%     &\hspace{-3em}\measure{b}{\p{\new{a}{x(a)}}}{\p{\new{a}{\apply{X}{a}{x(a)}}}}&\\
%     =&\new{a}{\measure{b}{x(a)}{\apply{X}{a}{x(a)}}}&\text{komutativnost}\\
%     =&\new{a}{\apply{\ctl X}{b,a}{\measure{b}{x(a)}{x(a)}}}&{(2)}\\
%     =&\new{a}{\apply{\ctl X}{b,a}{\discard{b}{x(a)}}}&\\
%     =&\new{a}{\apply{\ctl X}{a,b}{\apply{\ctl X}{b,a}{\discard{a}{x(b)}}}}&\\
%     =&\new{a}{\apply{\ctl X}{b,a}{\discard{a}{x(b)}}}&{(5)}\\
%     =&\new{a}{\apply{\had}{a}{\apply{\ctl Z}{a,b}{\apply{\had}{a}{\discard{a}{x(b)}}}}}&\\
%     =&\new{a}{\apply{\had}{a}{\apply{\ctl Z}{a,b}{\discard{a}{x(b)}}}}&{(3)}\\
%     =&\new{a}{\apply{\had}{a}{\measure{a}{x(b)}{\apply{Z}{b}{x(b)}}}}&{(2)}
% \end{align*}
\begin{align*}
     &\ \tmeasure{b}{\tnew{a}{x(a)}}{\tnew{a}{\tapply{X}{a}{x(a)}}}              &\\
    =&\ \tnew{a}{\tmeasure{b}{x(a)}{\tapply{X}{a}{x(a)}}}                        &(\ref{ax:L})\\
    =&\ \tnew{a}{\tapply{\ctl X}{b,a}{\tmeasure{b}{x(a)}{x(a)}}}                 &(\ref{ax:B})\\
    =&\ \tnew{a}{\tapply{\ctl X}{b,a}{\tdiscard{b}{x(a)}}}                       &(\text{def.})\\
    =&\ \tnew{a}{\tapply{\ctl X}{a,b}{\tapply{\ctl X}{b,a}{\tdiscard{a}{x(b)}}}} &(*)\\
    =&\ \tnew{a}{\tapply{\ctl X}{b,a}{\tdiscard{a}{x(b)}}}                       &(\ref{ax:E})\\
    =&\ \tnew{a}{\tapply{\had}{a}{\tapply{\ctl Z}{a,b}{\tapply{\had}{a}{\tdiscard{a}{x(b)}}}}}&(†)\\
    =&\ \tnew{a}{\tapply{\had}{a}{\tapply{\ctl Z}{a,b}{\tdiscard{a}{x(b)}}}}     &(\ref{ax:C})\\
    =&\ \tnew{a}{\tapply{\had}{a}{\tmeasure{a}{x(b)}{\tapply{Z}{b}{x(b)}}}}      &(\ref{ax:B})
\end{align*}

% \section{Razširitve}
